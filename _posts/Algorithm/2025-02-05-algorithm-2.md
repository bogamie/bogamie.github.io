---
title:  "2. 분할정복"
excerpt: "&nbsp;&nbsp; 분할정복은 하향식(top-down) 문제풀이 방식이다. 문제를 작은 부분 문제로 나누어 해결한 후, 이를 결합하여 원래 문제를 해결하는 방식이다."
date:   2025-02-05 20:13:25 +0900
categories: Algorithm
permalink: posts/2-divide-and-conquer
published: true
# Data Structure / Algorithm / Computer Architecture / System Programming / Computer Network / Database / Design Pattern / Web Programming / JavaScript / Java
# <img class="lazy invert" data-src="#center" alt="image" height="75%" width="75%" onclick="showImage(this)">
---
# 2.1 이분검색

&nbsp;&nbsp; **이분검색**(이진탐색, binary search)이란 정렬된 배열에서 특정한 값을 찾는 알고리즘이다. 배열에서 $x$를 찾는 과정은 다음과 같다.

1. 배열을 반으로 분할하고 $x$가 중간값과 같으면 종료한다.
2. 다를 때, $x$가 중간값보다 작으면 왼쪽 배열을, 크면 오른쪽 배열을 선택한다.
3. 선택한 반쪽 배열을 대상으로 `1번`을 반복한다.

<div class="bg"></div>
<div class="bg"></div>

```text
x = 31

10 14 19 26 27 31 33 35 42 44
 L           M              H: 27 < x

               31 33 35 42 44
                L     M     H: x < 35

               31 33
               LM  H         : x == 31        
```

## a. 반복을 이용한 이분검색

```c
index binarySearch(keytype S[], // 배열 S
                   index value, // 찾을 값
                   index n)     // 배열의 크기
{
    index low, high, u;
    low = 0, high = n - 1;

    while (low <= high) {
        u = ⌊(low + high) / 2⌋;

        if (value == S[u])
            return u;
        else if (value < S[u])
            high = u - 1;
        else
            low = u + 1;
    }
}
```

## b. 재귀를 이용한 이분검색

```c
index binarySearch(index low,  // 배열의 시작 인덱스
                   index high) // 배열의 끝 인덱스
{
    index u;

    if (low > high)
        return -1;
    else {
        u = ⌊(low + high) / 2⌋;

        if (value == S[u])
            return u;
        else if (value < S[u])
            return binarySearch(S, value, low, u - 1);
        else
            return binarySearch(S, value, u + 1, high);
    }
}
```

## c. 이분검색의 시간복잡도

&nbsp;&nbsp; 이분검색은 재귀 호출을 할 때마다 배열의 크기가 반으로 줄어 든다. 마지막 남은 원소가 1개일 때까지 반복하므로 시간복잡도는 다음과 같다.

$$
\begin{align}
    W(n) &= W(n/2) + 1 (n > 1, n\textrm{은 2의 거듭제곱}, W(1) = 1) \\
    W(n) &= \lg{n} + 1
\end{align}
$$

&nbsp;&nbsp; $n$이 2의 거듭제곱이라는 가정을 없애면 다음과 같다.

$$
W(n) = \lfloor\lg{n}\rfloor + 1 \in \Theta(\lg{n})
$$

# 2.2 합병정렬

&nbsp;&nbsp; **합병정렬**(merge sort)란 배열을 반으로 분할하여 각각 정렬한 후, 합병하는 방식의 정렬 알고리즘이다. 합병정렬은 다음과 같은 과정을 거친다.

1. 배열의 크기가 1이 될 때까지 반으로 분할한다.
2. 분할된 배열들을 합병하면서 정렬한다.

<div class="bg"></div>
<div class="bg"></div>

```text
35 11 27 42 33 10 14 19

35 11 27 42 | 33 10 14 19

35 11 | 27 42 | 33 10 | 14 19

35 | 11 || 27 | 42 || 33 | 10 || 14 | 19

11 35 | 27 42 | 10 33 | 14 19

11 27 35 42 | 10 14 19 33

10 11 14 19 27 33 35 42
```

## a. 합병정렬의 의사코드

```c
void mergeSort(int n,       // 배열의 크기
               keytype S[]) // 배열 S
{
    if (n > 1) {
        int u = ⌊n / 2⌋, // 배열 U의 크기
            v = n - u;   // 배열 V의 크기
        
        keytype U[u], V[v];
        copy S[0] through S[u] to U[0] through U[u];
        copy S[u + 1] through S[n - 1] to V[0] through V[v - 1];
        
        mergeSort(u, U);
        mergeSort(v, V);
        merge(u, v, S, U, V);
    }
}
```

<div class="bg"></div>

```c
void merge(int u,     // 배열 U의 크기
           int v,     // 배열 V의 크기
           keytype S[], // 배열 S
           keytype U[], // 배열 U
           keytype V[]) // 배열 V
{
    index i = 0, j = 0, k = 0;

    while (i < u && j < v) {
        if (U[i] < V[j]) {
            S[k] = U[i];
            i++;
        } else {
            S[k] = V[j];
            j++;
        }
        k++;
    }

    while (i < u) { // U에 남은 원소를 S에 복사
        S[k] = U[i];
        i++;
        k++;
    }

    while (j < v) { // V에 남은 원소를 S에 복사
        S[k] = V[j];
        j++;
        k++;
    }
}
```

### i. 합병하는 과정

```text
| k |          U          |          V          |            S            |
| 1 | [11]  27   35   42  | [10]  14   19   33  | 10                      |
| 2 | [11]  27   35   42  |  10  [14]  19   33  | 10 11                   |
| 3 |  11  [27]  35   42  |  10  [14]  19   33  | 10 11 14                |
| 4 |  11  [27]  35   42  |  10   14  [19]  33  | 10 11 14 19             |
| 5 |  11  [27]  35   42  |  10   14   19  [33] | 10 11 14 19 27          |
| 6 |  11   27  [35]  42  |  10   14   19  [33] | 10 11 14 19 27 33       |
| 7 |  11   27   35  [42] |  10   14   19   33  | 10 11 14 19 27 33 35    |
| 8 |  11   27   35   42  |  10   14   19   33  | 10 11 14 19 27 33 35 42 |
```
## b. 개선된 합병정렬

&nbsp;&nbsp; **제자리정렬**(in-place sort)이란 추가적인 배열(저장소)를 사용하기 않고 정렬하는 방식이다. `a`의 합병정렬 알고리즘은 입력 배열 `S` 이외에 배열 `U`와 `V`를 추가적으로 사용하므로 제자리정렬이 아니다. 초기 배열의 크기를 $n$이라고 할 때, `mergeSort` 함수를 처음 호출할 때 두 배열의 원소 개수 합은 약 $n$이고, 이후 재귀 호출할 때마다 배열의 크기가 반으로 줄어들기 때문에 추가적으로 만들어지는 배열 원소의 총 개수는 약 $n(1+\frac{1}{2}+\frac{1}{4}+\cdots) = 2n$이다.

&nbsp;&nbsp; 메모리 사용량을 줄이기 위해 $n$개의 원소를 가진 배열 하나만 사용하여 합병정렬을 구현할 수 있다. 개선된 합병정렬 알고리즘은 [2.1.b 재귀를 이용한 이분검색](#b-재귀를-이용한-이분검색)과 유사한 방법을 사용한다.

```c
void mergeSort(index low,  // 배열의 시작 인덱스
               index high) // 배열의 끝 인덱스
{
    index mid;

    if (low < high) {
        mid = ⌊(low + high) / 2⌋;
        mergeSort(low, mid);
        mergeSort(mid + 1, high);
        merge(low, mid, high);
    }
}
```

<div class="bg"></div>

```c
void merge(index low,  // 배열의 시작 인덱스
           index mid,  // 배열의 중간 인덱스
           index high) // 배열의 끝 인덱스
{
    index i = low, j = mid + 1, k = 0;
    keytype U[high - low + 1];

    while (i <= mid && j <= high) {
        if (S[i] < S[j])
            U[k++] = S[i++];
        else
            U[k++] = S[j++];
    }

    while (i <= mid)
        U[k++] = S[i++];

    while (j <= high)
        U[k++] = S[j++];

    for (i = low, k = 0; i <= high; i++, k++)
        S[i] = U[k];
}
```

## c. 합병정렬의 시간복잡도

&nbsp;&nbsp; 합병정렬은 배열을 반으로 분할하고 합병하는 과정을 반복하므로 시간복잡도는 다음과 같다.

$$
\begin{align}
    W(n) &= 2W(n/2) + n (n > 1, n\textrm{은 2의 거듭제곱}) \\
    W(1) &= 0 \\
    W(n) &= n\lg{n}-(n-1) 
\end{align}
$$

&nbsp;&nbsp; $n$이 2의 거듭제곱이 아닐 때는 다음과 같다.

$$
\begin{align}
    W\left( n \right)&=W\left( \left\lfloor \frac{n}{2} \right\rfloor \right)+W\left( \left\lceil \frac{n}{2} \right\rceil \right)+n-1 \\
    W\left( n \right)&\in \Theta\left( n\lg{n} \right)
\end{align}
$$

# 2.3 퀵정렬

&nbsp;&nbsp; **퀵정렬**(quick sort)은 기준값(pivot)을 선정하여 기준값보다 작은 원소는 왼쪽, 크거나 같은 원소는 오른쪽으로 분할하는 방식의 정렬 알고리즘이다. 퀵정렬은 다음과 같이 작동한다.

1. 배열에서 기준값을 선택한다.
2. 기준값보다 작은 원소는 왼쪽, 크거나 같은 원소는 오른쪽으로 분할한다.
3. 분할된 배열에 대해 `1`과 `2`를 반복한다.

<div class="bg"></div>
<div class="bg"></div>

<img class="lazy invert" data-src="https://github.com/user-attachments/assets/2afe1c4d-4da2-4c12-b9d1-7e2b47a1398e#center" alt="image" height="50%" width="50%" onclick="showImage(this)">


# 2.4 쉬트라쎈의 행렬곱셈 알고리즘

# 2.5 큰 정수 계산법